// TODO: Вариант с использованием типов:

type TypePerson = {
    age: number // свойство "age" типа number (возраст пользователя)
}
// @ts-ignore
type TypeUser = {
    name: string // свойство "name" типа string (имя пользователя)
    email: string // свойство "email" типа string (адрес электронной почты пользователя)
} & TypePerson

// @ts-ignore
const user: TypeUser = {
    email: '834565ttregdefg@rg.ewr', // присваиваем значению свойства "email" строку
    name: 'Max', // присваиваем значению свойства "name" строку
    age: 21, // присваиваем значению свойства "age" число
}

// Преимущества:
// - Можно использовать оператор '&' для объединения нескольких типов и создания более сложной структуры данных.
// - Позволяет создавать более гибкие и мощные типы, включая объединение, пересечение и другие операции.
// - Поддерживает использование выражений и условий для определения типов.

// Недостатки:
// - Не поддерживает наследование типов, как это делает интерфейс.
// - Может быть менее читаемым и понятным для некоторых разработчиков, особенно если используются сложные типы и операторы.

// TODO: Вариант с использованием интерфейсов:

interface IUserAge {
    age: number // свойство "age" типа number (возраст пользователя)
}

interface IUser extends IUserAge {
    name: string // свойство "name" типа string (имя пользователя)
    email: string // свойство "email" типа string (адрес электронной почты пользователя)
}
// @ts-ignore
const user: IUser = {
    email: '834565ttregdefg@rg.ewr', // присваиваем значению свойства "email" строку
    name: 'Max', // присваиваем значению свойства "name" строку
    age: 21, // присваиваем значению свойства "age" число
}

// Преимущества:
// - Поддерживает наследование интерфейсов, позволяя создавать иерархии и расширять структуру данных.
// - Более понятный и простой синтаксис для объявления свойств и методов объектов.
// - Позволяет определять контракт и ожидаемую структуру данных.

// Недостатки:
// - Не поддерживает операторы объединения и пересечения, что ограничивает возможности создания сложных типов.
// - Не позволяет использовать выражения и условия для определения типов, как это делает типизация.
